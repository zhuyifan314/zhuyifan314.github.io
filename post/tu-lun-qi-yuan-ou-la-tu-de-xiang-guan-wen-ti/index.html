<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>图论起源——欧拉图的相关问题 | Creater&#39;s World</title>
<link rel="shortcut icon" href="https://zhuyifan314.github.io/favicon.ico?v=1621602739288">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://zhuyifan314.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="图论起源——欧拉图的相关问题 | Creater&#39;s World - Atom Feed" href="https://zhuyifan314.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="图论起源——欧拉图在信息学竞赛中时常出现，本文将简单地介绍一下。

一、引入
有这么一座城，城里有 777 座桥。问是否有一条路径，可以 不重复的地走遍 777 座桥。这就是著名的 七桥问题，在相当长的时间内都无人解答。直到 1736173..." />
    <meta name="keywords" content="欧拉图,学习笔记" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zhuyifan314.github.io">
  <img class="avatar" src="https://zhuyifan314.github.io/images/avatar.png?v=1621602739288" alt="">
  </a>
  <h1 class="site-title">
    Creater&#39;s World
  </h1>
  <p class="site-description">
    Hello World!
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              图论起源——欧拉图的相关问题
            </h2>
            <div class="post-info">
              <span>
                2021-04-18
              </span>
              <span>
                13 min read
              </span>
              
                <a href="https://zhuyifan314.github.io/tag/oR4OuPOPM/" class="post-tag">
                  # 欧拉图
                </a>
              
                <a href="https://zhuyifan314.github.io/tag/ted_gNn_k/" class="post-tag">
                  # 学习笔记
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://img.imgdb.cn/item/607b7ab58322e6675c12142c.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>图论起源——欧拉图在信息学竞赛中时常出现，本文将简单地介绍一下。</p>
<!-- more -->
<h2 id="一-引入">一、引入</h2>
<p>有这么一座城，城里有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 座桥。问是否有一条路径，可以 <strong>不重复的地走遍 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 座桥</strong>。这就是著名的 <strong>七桥问题</strong>，在相当长的时间内都无人解答。直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1736</mn></mrow><annotation encoding="application/x-tex">1736</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">3</span><span class="mord">6</span></span></span></span> 年，数学家欧拉经过研究发表了论文《哥尼斯堡的七座桥》，给出了解答。如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/9hdv5ga2.png" alt="" loading="lazy"></figure>
<p>他将七桥问题改成第二幅图，那么问题转化为：<strong>能否从无向图的一个顶点出发走出一条道路，每条边恰好经过一次</strong>。满足上述条件的路径叫 <strong>欧拉路径（eulerian path）</strong>，也可以形象的称为“一笔画”。而含有欧拉路径的图叫 <strong>欧拉图</strong>。从那时起，图论作为数学的一个新的分支而诞生。因此，欧拉图可以说是 <strong>图论的起源</strong>，也是图论研究的重要的一部分。</p>
<p>而在信息学竞赛中，欧拉图也是图论题目的一个基本模型。本文将会详细地讲解欧拉图的 <strong>概念</strong>、<strong>性质</strong>、<strong>判定</strong>、<strong>实现</strong> 以及 <strong>例题</strong>。同时因为本人才疏学浅，如果有何错误请各位指出。</p>
<h2 id="二-定义">二、定义</h2>
<p>由于本文会出现一些图论的专业词汇，故给出一些词汇的定义，如果下文有不知道意思的词可以到这里来看。</p>
<ul>
<li>
<p><strong>度</strong>：</p>
<p>图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 中与顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 相连的边数称为图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 中顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的 <strong>度</strong>。特别地，对于有向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>，进入顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的边的条数称为顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的 <strong>入度</strong>；从顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 引出的边的条数称为顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的 <strong>出度</strong>。</p>
</li>
<li>
<p><strong>桥</strong>：</p>
<p>若删去图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 中的边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 后，图的连通分量（也就是连通块）数量增加，则称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 的 <strong>桥</strong>。</p>
</li>
<li>
<p><strong>欧拉路径</strong>：</p>
<p>通过无向图或者有向图中所有边 <strong>恰好一次</strong>的路径称作 <strong>欧拉路径</strong>。如下图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mo>&gt;</mo><mn>2</mn><mo>−</mo><mo>&gt;</mo><mn>3</mn><mo>−</mo><mo>&gt;</mo><mn>4</mn><mo>−</mo><mo>&gt;</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1-&gt;2-&gt;3-&gt;4-&gt;2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 即为一条欧拉路径：</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/h09s1sza.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>欧拉回路</strong>：</p>
<p>通过无向图或者有向图中所有边 <strong>恰好一次</strong>的 <strong>回路</strong>（相当于一个 <strong>环</strong>） 称作 <strong>欧拉回路</strong>。如下图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mo>&gt;</mo><mn>2</mn><mo>−</mo><mo>&gt;</mo><mn>3</mn><mo>−</mo><mo>&gt;</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1-&gt;2-&gt;3-&gt;1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 即为一条欧拉回路：</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://cdn.luogu.com.cn/upload/image_hosting/964u0jah.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>半欧拉图</strong>：</p>
<p>有 <strong>欧拉路径</strong> 但没有 <strong>欧拉回路</strong> 的图（无向图或有向图）称为 <strong>半欧拉图</strong>。</p>
</li>
<li>
<p><strong>欧拉图</strong>：</p>
<p>有 <strong>欧拉回路</strong> 的图（无向图或者有向图）称为 <strong>欧拉图</strong>（简称 E 图）。</p>
</li>
</ul>
<h2 id="三-定理">三、定理</h2>
<ul>
<li>
<p><strong>定理</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>：</p>
<p>无向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 是 <strong>欧拉图</strong>，当且仅当图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> <strong>连通</strong> 且所有顶点的度都是 <strong>偶数</strong>。</p>
</li>
</ul>
<p><strong>证明</strong>：首先证明 <strong>必要性</strong>。由于欧拉路径要遍历每一条边，所以任意两个点都是可以互相到达的，因此若图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 有欧拉路径，则其一定连通。因为欧拉回路的要求是走遍所有边恰好一次，不难发现，所有点的 <strong>“进出”次数</strong> 应该是一样的（<strong>出</strong> 和 <strong>入</strong>是对应的，一定会成对出现），也就是度数都为 <strong>偶数</strong>。因此若图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 存在欧拉回路，则图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 一定连通且所有顶点度都是偶数。</p>
<p>其次证明 <strong>充分性</strong>。若从图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 中的任意一点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">u_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 出发沿一条边走向相邻的点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 的度数是偶数，一定可以从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 沿一条边走向相邻的点，如此反复，每条边仅经过一次，最终一定会回到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">u_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，得到一个圈 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就是图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>，定理得证；否则的话，由于图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 是连通的，所以在剩下的图中一定有一个和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 公共的顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">u_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">u_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 出发，和上面的流程类似，一定有一个圈 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将两个圈拼起来任是一个回路。如此反复，一定有一刻得到的图是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>，定理得证。</p>
<p>如图：</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.luogu.com.cn/upload/image_hosting/t23ovyhc.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>定理</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>：</p>
<p>无向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 是 <strong>半欧拉图</strong>，当且仅当图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> <strong>连通</strong> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 中仅有两个 <strong>奇度顶点</strong>。</p>
</li>
</ul>
<p><strong>证明</strong>：将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 的两个奇度顶点连接，由定理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 是一个欧拉图，去掉环上的一边就变为了半欧拉图。</p>
<p>如图：</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.luogu.com.cn/upload/image_hosting/2sm9g3ui.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>定理</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>：</p>
<p>当有向图 D 的有向边看做无向边时连通，且所有的顶点的 <strong>出度和入度都相等</strong> 时，D 为 <strong>欧拉图</strong>。</p>
</li>
</ul>
<p><strong>证明</strong>：与定理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 类似。</p>
<p>如图：</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.luogu.com.cn/upload/image_hosting/zmmhjdka.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>定理</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>：</p>
<p>当有向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 的有向边看做无向边时连通，且除了两个顶点外，<strong>其余顶点的出度与入度都相等</strong>，而这两个顶点中一个顶点的 <strong>出度与入度之差为</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，另一个顶点的 <strong>出度与入度之差为</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 为 <strong>半欧拉图</strong>。</p>
</li>
</ul>
<p><strong>证明</strong>：同定理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 类似。</p>
<p>如图：</p>
<figure data-type="image" tabindex="7"><img src="https://cdn.luogu.com.cn/upload/image_hosting/2hcwkr7i.png" alt="" loading="lazy"></figure>
<h2 id="四-推论">四、推论</h2>
<p>由上面的定理我们可以得到一些推论。</p>
<ul>
<li>
<p><strong>推论</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>：</p>
<p>若无向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 连通，且仅有两个奇度顶点，其 <strong>欧拉路径</strong> 一定以这两个顶点为 <strong>端点</strong>。</p>
</li>
<li>
<p><strong>推论</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>：</p>
<p>若有向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span> 连通（指将有向边看做无向边时连通），且除 <strong>出、入度之差为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>的两个顶点</strong> 之外，所有顶点的 <strong>出度与入度都相等</strong>，其 <strong>欧拉路径</strong> 必定以 <strong>出、入之差为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></strong> 的顶点为端点。</p>
</li>
<li>
<p><strong>推论</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>：</p>
<p><strong>欧拉图</strong> 中所有点的度数都是 <strong>偶数</strong>。</p>
</li>
<li>
<p><strong>推论</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>：</p>
<p>对于无向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 来说，若其是欧拉图，则其存在 <strong>圈分解</strong>。圈分解即用若干个圈（不重复经过顶点的回路）使图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 的每一条边恰好经过一次。如下面的欧拉图即可分解为两个圈：</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.luogu.com.cn/upload/image_hosting/kdrmivkj.png" alt="" loading="lazy"></figure>
</li>
</ul>
<p><strong>证明</strong>：这和上面的定理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的证明过程是一样的，事实上，该推论可以描述成 <strong>图中点度数均为偶数等价于存在圈分解</strong>。</p>
<h2 id="五-判定">五、判定</h2>
<p>我们再对欧拉图的判定进行一下总结。</p>
<ol>
<li>判断 <strong>欧拉路径</strong> 是否存在</li>
</ol>
<ul>
<li>
<p><strong>无向图</strong>：</p>
<ul>
<li>
<p>连通；</p>
</li>
<li>
<p>只有两个顶点度数为奇数；</p>
</li>
<li>
<p>其余所有顶点度数为偶数。</p>
</li>
</ul>
</li>
<li>
<p><strong>有向图</strong>：</p>
<ul>
<li>
<p>连通；</p>
</li>
<li>
<p>有一个顶点出度比入度大 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，有一个顶点入度比出度大 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</p>
</li>
<li>
<p>其余所有顶点的入度等于出度。</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>判断 <strong>欧拉回路</strong> 是否存在</li>
</ol>
<ul>
<li>
<p><strong>无向图</strong>：</p>
<ul>
<li>
<p>连通；</p>
</li>
<li>
<p>所有顶点度数都是偶数。</p>
</li>
</ul>
</li>
<li>
<p><strong>有向边</strong>：</p>
<ul>
<li>
<p>连通（指将有向边看做无向边时连通）；</p>
</li>
<li>
<p>所有的顶点入度等于出度。</p>
</li>
</ul>
</li>
</ul>
<p>在做题时若需要判断一个图是不是欧拉图，就可以根据上面的几条进行判断。</p>
<h2 id="六-实现">六、实现</h2>
<p>前面介绍了这么多，下面我们将会对如何在欧拉图中求出一条欧拉回路进行讲解。</p>
<p>求欧拉回路主要有两种算法： Fluery 算法和 Hierholzer 算法。本文主要讲解 Hierholzer 算法。</p>
<ul>
<li>
<p><strong>Fluery 算法</strong></p>
<p>也称避桥法，是一种较暴力的算法。时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>m</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>， 效率不及 Hierholzer 算法，实用性不高，这里只是稍作介绍。</p>
<p>简单来说，其算法关键为每次选择下一条边优先选 <strong>不是桥</strong> 的边。</p>
</li>
<li>
<p><strong>Hierholzer 算法</strong></p>
<p>也称逐步插入回路法。时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，较 Fluery 算法更优，是算法竞赛中最常用的求欧拉路径的算法。</p>
<p>该算法的思路与定理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的证明过程相似。从 <strong>任意一点</strong> 出发，不停沿 <strong>未走过</strong> 的边向前，直到 <strong>无法再走</strong> 为止。这时一定形成了一个回路，但还有边未被访问。这时再从未被访问过的点出发，在从这点走出一个回路，将这个回路与之前的回路 <strong>拼接</strong>。如此反复，直到所有边都被访问过为止。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>
<p>任选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> 中的一个顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">u_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">u_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开始 DFS，通过未访问过的边遍历相邻的点。</p>
</li>
<li>
<p>一直到无法遍历为止，将当前的结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 加入路径数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 中。；</p>
</li>
<li>
<p>一直到所有的边都被访问过，此时的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 的 <strong>反序</strong> 即为所求的欧拉回路。</p>
</li>
</ol>
<p>对于此处为何是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 的反序做下解释。因为 Hierholzer 算法是不断往下搜索的，直到最后无路可走为止。此时的点（即 <strong>无路可走</strong> 时的顶点）一定是满足条件的。若是正序的话，前面记录的顶点可能在继续往下搜索时不符合条件。因此所求的欧拉回路是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 的<strong>反序</strong>。同时由于是反序，我们可以用 <strong>栈</strong> 来记录路径。</p>
<p>注意，上面是在欧拉图中找欧拉回路，如果说是要找欧拉路径的话，就要记录每个点的度数，从 <strong>奇度</strong> 顶点出发。</p>
<p>有时候题目并不保证图是连通的，这是就需要提前判断图的连通性，可以用 <strong>并查集</strong> 来做。</p>
<p><strong>代码</strong>（这里用邻接矩阵实现）：</p>
</li>
</ul>
<pre><code class="language-cpp">void dfs(int u)
{
	for(int v=1;v&lt;=n;v++)
		if(e[u][v])//若有边
		{
			e[u][v]--;//删边
			e[v][u]--;
			dfs(v);
		}		
	s.push(u);	//加入路径
 } 
</code></pre>
<h2 id="七-例题">七、例题</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2731">P2731 [USACO3.3]骑马修栅栏 Riding the Fences</a></li>
</ul>
<p>本题就是欧拉回路的板子题。需要注意的是：</p>
<ol>
<li>
<p>本题有可能不是欧拉回路而是欧拉路径，那么此时就要从 <strong>度数为奇数</strong> 的点开始。</p>
</li>
<li>
<p>由于最后的答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 的反序，因此我们可以用栈来存。</p>
</li>
<li>
<p>本题需要输出 <strong>字典序小</strong> 的，因此需要用 vector 进行内部排序。</p>
</li>
<li>
<p>本题最小点不一定是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，需要进行处理。</p>
</li>
</ol>
<p><strong>代码</strong>：</p>
<pre><code class="language-cpp">#include&lt;stack&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=1029;
int m,u,v;
int ind[N];//每个点的度数 
int minn=1e9;//点的最大值和最小值 
int vis[N][N],cnt;
vector&lt;int&gt;e[N]; 
stack&lt;int&gt;s;
void dfs(int u)
{
	for(int i=0;i&lt;e[u].size();i++)
	{
		int v=e[u][i];
		if(vis[u][v])
		{
			vis[u][v]--;//删边 
			vis[v][u]--;
			dfs(v);
		}	
	}
	s.push(u);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;m);
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		ind[u]++;
		ind[v]++;
		vis[u][v]++;
		vis[v][u]++;
		e[u].push_back(v);
		e[v].push_back(u); 
		minn=min(minn,min(u,v));
	}
	
	for(int i=minn;i&lt;=m;i++)
		sort(e[i].begin(),e[i].end());
		
	int st=minn;
	
	for(int i=minn;i&lt;=m;i++)
		if(ind[i]%2)
		{
			st=i;
			break;
		}
	
	dfs(st);
		
	while(!s.empty())
	{
		printf(&quot;%d\n&quot;,s.top());
		s.pop();
	}
	return 0;
}
</code></pre>
<ul>
<li><a href="https://www.luogu.com.cn/problem/UVA10129">UVA10129 单词 Play on Words</a></li>
</ul>
<p><strong>题意</strong>：</p>
<p>给出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个单词，问是否可以将这些单词排成一个序列，满足每个单词的 <strong>第一个字母</strong> 和上一个单词的 <strong>最后一个字母相等</strong>。</p>
<p><strong>思路</strong>：</p>
<p>每个单词的 <strong>首尾字母</strong> 就是图上的 <strong>顶点</strong>，<strong>首尾字母的连线</strong> 即为图上的<strong>边</strong>。题目中的序列实际上就是求恰好经过每一条边的路径，即求 <strong>有向图</strong> 中的 <strong>欧拉路径</strong>。</p>
<p>至于判断是否存在欧拉路径，根据上文的内容即可解决：首先要判断 <strong>连通性</strong>；其次在 <strong>有向图</strong> 中，要么所有点 <strong>出度等于入度</strong>，要么 <strong>仅有一个顶点出度比入度大 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，仅有一个顶点入度比出度大</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。对其进行判断即可。</p>
<p><strong>代码</strong>：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;

const int N=37;
int t,in[N],out[N],n,u,v,in_num,out_num;
bool vis[N],e[N][N];
string s;

void init()
{
	in_num=0;
	out_num=0;
	memset(vis,false,sizeof(vis));
	memset(e,false,sizeof(e));
	memset(in,0,sizeof(in));
	memset(out,0,sizeof(out));
}

void dfs(int u)
{
	vis[u]=false;//搜索时将访问过的点标记为false 
	for(int i=1;i&lt;=26;i++)
		if(e[u][i]&amp;&amp;vis[i])
			dfs(i);
}

bool check()
{
	init();
	
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;s;
		u=s[0]-'a'+1;
		v=s[s.size()-1]-'a'+1;
		e[u][v]=e[v][u]=true;//边 
		vis[u]=vis[v]=true;//判断连通性 
		out[u]++;//出度 
		in[v]++;//入度 
	}
	
	dfs(u);
	
	for(int i=1;i&lt;=26;i++)
	{
		if(vis[i])//如果不连通，不存在欧拉路径 
			return false;
		if(in[i]-out[i]==1)//入度比出度大1的点
			out_num++;
		else if(in[i]-out[i]==-1)//出度比入度大1的点
			in_num++;
		else if(in[i]!=out[i])//除此之外的都不是欧拉路径
			return false;		
}
	if((in_num==1&amp;&amp;out_num==1)||(in_num==0&amp;&amp;out_num==0))
		return true;
	
	return false;
}


int main()
{
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		if(check())
			printf(&quot;Ordering is possible.\n&quot;);
		else
			printf(&quot;The door cannot be opened.\n&quot;);
	}
	return 0;
}
</code></pre>
<ul>
<li><strong>其他例题</strong>：</li>
</ul>
<p><a href="https://www.luogu.com.cn/problem/P1341">P1341 无序字母对</a>（找出 <strong>字典序最小</strong> 的欧拉回路）</p>
<p><a href="https://www.luogu.com.cn/problem/P3520">P3520 [POI2011]SMI-Garbage</a>（无向图中找欧拉回路）</p>
<p><a href="https://www.luogu.com.cn/problem/P6066">P6066 [USACO05JAN]Watchcow S</a></p>
<p>把一条无向边当作两条有向边做即可。</p>
<h2 id="八-参考文献">八、参考文献</h2>
<ul>
<li>
<p>2018国家集训队论文 《欧拉图相关的生成与计数问题探究》—— 陈通</p>
</li>
<li>
<p><a href="https://oi-wiki.org/graph/euler/#_6">oi-wiki</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/wkfvawl/p/9626163.html">王陸 的博客</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_35649707/article/details/75578102">DZYO 的博客</a></p>
</li>
</ul>
<h2 id="九-后记">九、后记</h2>
<p>事实上，欧拉图还有更多有趣的性质和问题，本文只是窥探了其冰山一角，希望能起到抛砖引玉的作用。</p>
<p>感谢 @<a href="https://www.luogu.com.cn/user/228866">爱彩虹的牛</a>一直以来对我的支持和帮助。</p>
<p>感谢 @<a href="https://www.luogu.com.cn/user/40318">Acfboy</a> 给我提出的的宝贵意见。</p>
<p>感谢 @<a href="https://www.luogu.com.cn/user/304995">PanH</a> 学长对我的指导。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E5%BC%95%E5%85%A5">一、引入</a></li>
<li><a href="#%E4%BA%8C-%E5%AE%9A%E4%B9%89">二、定义</a></li>
<li><a href="#%E4%B8%89-%E5%AE%9A%E7%90%86">三、定理</a></li>
<li><a href="#%E5%9B%9B-%E6%8E%A8%E8%AE%BA">四、推论</a></li>
<li><a href="#%E4%BA%94-%E5%88%A4%E5%AE%9A">五、判定</a></li>
<li><a href="#%E5%85%AD-%E5%AE%9E%E7%8E%B0">六、实现</a></li>
<li><a href="#%E4%B8%83-%E4%BE%8B%E9%A2%98">七、例题</a></li>
<li><a href="#%E5%85%AB-%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">八、参考文献</a></li>
<li><a href="#%E4%B9%9D-%E5%90%8E%E8%AE%B0">九、后记</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://zhuyifan314.github.io/post/tan-xin-huan-neng-zhe-me-wan-qian-tan-jin-jie-tan-xin/">
              <h3 class="post-title">
                贪心还能这么玩？——浅谈进阶贪心
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://zhuyifan314.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
